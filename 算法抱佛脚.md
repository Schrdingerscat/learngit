#include<bits/stdc++.h>


# 高精度计算
在说高精度加减乘除运算之前，我们先搞明白什么是高精度运算？

实际上高精度就是说参与运算的数据和运算结果的范围，超出标准数据类型能表示的数据大小范围的运算。这个时候，如果要得到正确的计算结果，显然不能依靠普通方法实现了。而要在普通运算原理的基础上，加以辅助算法来实现超大数据的计算。例如：求两个100位的数据的和，或者计算两个100位的数字乘积。这时就要用到高精度算法了。
一、高精度加法：
    
高精度加法的实现原理：

1、计算结果的位数
358934760892734899共18位
38960302975237462共17位
故结果不会超过19位。
2、将要计算的数字分割成多段，按照顺序排列（这里以0-32767作为每一存储单位存储的数的限制）：

（为提高空间利用效率，可以一个存储单位存储多位数。）
3、将两数相加。

4、输出结果。
从高位到低位依次输出。除最高位以外，其他低位上不足4位的要在前面补上0。

5.代码实现如下

``` C++
#include<iostream>  
#include<cstring>  
using namespace std;  
int main()  
{  
  string str1,str2;  
  int a[250],b[250],len;   //数组的大小决定了计算的高精度最大位数  
  int i;  
  memset(a,0,sizeof(a));  
  memset(b,0,sizeof(b));  
  cin>>str1>>str2;   //输入两个字符串  
  a[0]=str1.length();  //取得第一个字符串的长度  
  for(i=1;i<=a[0];i++)  //把第一个字符串转换为整数，存放在数组a中  
    a[i]=str1[a[0]-i]-'0';  
  b[0]=str2.length();   //取得第二个字符串长度  
  for(i=1;i<=b[0];i++)   //把第二个字符串中的每一位转换为整数，存放在数组B中  
    b[i]=str2[b[0]-i]-'0';  
  len=(a[0]>b[0]?a[0]:b[0]);   //取两个字符串最大的长度  
  for(i=1;i<=len;i++)   //做按位加法，同时处理进位  
  {  
    a[i]+=b[i];  
    a[i+1]+=a[i]/10;  
    a[i]%=10;     
  }  
  len++;    //下面是去掉最高位的0，然后输出。  
  while((a[len]==0)&&(len>1)) len--;  
  for(i=len;i>=1;i--)  
    cout<<a[i];  
  return 0;   
}  
```
//注意：两个数相加，结果的位数，应该比两个数中大的那个数多一位。 
二、高精度减法：

  高精度减法的实现原理：

   1.高精度减法相比高精度加法来说，稍微复杂一点，因为减法在差为负数时处理的细节更多一点：当被减数小于减数时，差为负数，差的绝对值是减数减去被减数；在程序实现上用一个变量来存储符号位，用另一个数组存差的绝对值。

   2.实现流程

(1).先比较大小

(2).决定输出符号，为正还是为负

(3).按位减法，并注意处理借位

   3.代码实现如下：
``` C++
#include<iostream>  
using namespace std;  
int compare(string s1,string s2);  
int main()  
{  
  string str1,str2;  
  int a[250],b[250],len;  
  int i;  
  memset(a,0,sizeof(a));  
  memset(b,0,sizeof(b));  
  cin>>str1>>str2;  
  a[0]=str1.length();  
  for(i=1;i<=a[0];i++)  
    a[i]=str1[a[0]-i]-'0';  
  b[0]=str2.length();  
  for(i=1;i<=b[0];i++)  
    b[i]=str2[b[0]-i]-'0';  
  if((compare(str1,str2))==0)  //大于等于，做按位减，并处理借位。  
  {  
    for(i=1;i<=a[0];i++)  
      {a[i]-=b[i];  
       if (a[i]<0) {a[i+1]--;a[i]+=10;}  
      }  
    a[0]++;  
    while((a[a[0]]==0)&&(a[0]>1)) a[0]--;  
    for(i=a[0];i>=1;i--)  
      cout<<a[i];  
    cout<<endl;   
  }                            
  else  
  {  
    cout<<'-';  //小于就输出负号  
    for(i=1;i<=b[0];i++)  //做按位减，大的减小的  
      {b[i]-=a[i];  
       if (b[i]<0) {b[i+1]--;b[i]+=10;}  
      }  
    b[0]++;  
    while((b[b[0]]==0)&&(b[0]>1)) b[0]--;  
    for(i=b[0];i>=1;i--)  
      cout<<b[i];  
    cout<<endl;          
  }  
  return 0;   
}  
int compare(string s1,string s2)  //比较字符串（两个数）数字的大小，大于等于返回0，小于返回1。  
{  
  if(s1.length()>s2.length()) return 0;  //先比较长度，哪个字符串长，对应的那个数就大  
  if(s1.length()<s2.length()) return 1;  
  for(int i=0;i<=s1.length();i++)  //长度相同时，就一位一位比较。  
  {  
    if(s1[i]>s2[i]) return 0;  
    if(s1[i]<s2[i]) return 1;                            
  }  
  return 0;   //如果长度相同，每一位也一样，就返回0，说明相等  
}  
``` C++

三、高精度乘法实现

    高精度乘法实现原理：

   1.由于数字较大，无法使用简单的数据结构进行存储，选用数组和字符串来存储数字，字符串方便我们对于高位整数的输入，而整形数组的简便有利于每个位数的计算，结合两者优点便可实现高精度乘法。

    2.实现过程：

(1).通过两个字符串输入两个整数

(2).引入两个数组，将每个整数切割存储到数组里面

(3).进行每一位的运算

(4).处理进位

(5).输出结果

  3.代码实现如下：

``` C++
#include<iostream>  
#include<cstring>  
using namespace std;  
int main()  
{  
  string str1,str2;  
  int a[250],b[250],c[500],len;    //250位以内的两个数相乘  
  int i,j;  
  memset(a,0,sizeof(a));  
  memset(b,0,sizeof(b));  
  cin>>str1>>str2;  
  a[0]=str1.length();  
  for(i=1;i<=a[0];i++)  
    a[i]=str1[a[0]-i]-'0';  
  b[0]=str2.length();  
  for(i=1;i<=b[0];i++)  
    b[i]=str2[b[0]-i]-'0';  
  memset(c,0,sizeof(c));  
  for(i=1;i<=a[0];i++)   //做按位乘法同时处理进位，注意循环内语句的写法。  
    for(j=1;j<=b[0];j++)  
    {  
    c[i+j-1]+=a[i]*b[j];  
    c[i+j]+=c[i+j-1]/10;  
    c[i+j-1]%=10;     
    }  
  len=a[0]+b[0]+1;  //去掉最高位的0，然后输出  
  while((c[len]==0)&&(len>1)) len--;   //为什么此处要len>1??  
  for(i=len;i>=1;i--)  
    cout<<c[i];  
  return 0;   
}  
```
四、高精度除法实现

高精度除法实现原理：高精度除法这一块比较复杂，它可以分为两种情况：

第一种情况：高精除以低精，实际上就是对被除的每一位，包括前面的余数都除以除数。

代码实现如下：
``` C++
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int main()
{
    char a1[100],c1[100];
    int a[100],c[100],lena,i,x=0,lenc,b;
    memset(a,0,sizeof(a));
    memset(c,0,sizeof(c));
    gets(a1);  //输入高精度被除数 
    cin>>b;    //输入低精度除数 
    lena=strlen(a1);
    for (i=0;i<=lena-1;i++)
　　      a[i+1]=a1[i]-48;   //将高精度被除数放入a数组 
    for (i=1;i<=lena;i++)            //按位相除
        {
            c[i]=(x*10+a[i])/b;
                x=(x*10+a[i])%b;
        }
　   lenc=1;
    while (c[lenc]==0&&lenc<lena) 
 　  lenc++;       //删除前导0
    for (i=lenc;i<=lena;i++) 
    cout<<c[i];
    cout<<endl;
    return 0;
}

```


第二种情况：高精除以高精

代码实现如下：

```C++
#include<iostream>
#include<cstring>
using namespace std;
int a[100],b[100],c[100];
int compare(int a[],int b[])//比较a、b，若a>b为1；若a<b为-1；若a=b为0
{
    int i;
    if(a[0]>b[0])
        return 1;
    if(a[0]<b[0])
        return -1;
    for(i=a[0];i>0;i--)//从高位到低位比较
    {
        if(a[i]>b[i])
            return 1;
        if(a[i]<b[i])
            return -1;
    }
    return 0;
}

void subduction(int a[],int b[])//计算a=a-b
{
    int flag;
    int i;

    flag=compare(a,b);
    if(flag==0)//相等
    {
        a[0]=0;
        return;
    }
    if(flag==1)//大于
    {
        for(i=1;i<=a[0];i++)
        {
            if(a[i]<b[i])//若不够向上借位
            {
                a[i+1]--;
                a[i]+=10;
            }
            a[i]-=b[i];
        }
        while(a[0]>0&&a[a[0]]==0)//删除前导0
            a[0]--;
        return;
    }
}
```

``` C++
int main()
{
    char str1[100],str2[100];
    int i,j;

    memset(a,0,sizeof(a));
    memset(b,0,sizeof(b));
    memset(c,0,sizeof(c));
     
    cin>>str1>>str2;
    a[0]=strlen(str1);//a[0]存储串1的位数
    b[0]=strlen(str2);//b[0]存储串2的位数
    for(i=1;i<=a[0];i++)
        a[i]=str1[a[0]-i]-'0';
    for(i=1;i<=b[0];i++)
        b[i]=str2[b[0]-i]-'0';

 

    int temp[100];
    c[0]=a[0]-b[0]+1;
    for(i=c[0];i>0;i--)
    {
        memset(temp,0,sizeof(temp));
     
        for(j=1;j<=b[0];j++)//从i开始的地方，复制数组b到数组temp
            temp[j+i-1]=b[j];
        temp[0]=b[0]+i-1;
     
        while(compare(a,temp)>=0)//用减法模拟
        {
            c[i]++;
            subduction(a,temp);
        }
    }
     
    while(c[0]>0&&c[c[0]]==0)//删除前导0
        c[0]--;
     
    cout<<"商为：";
    if(c[0]==0)//输出结果
        cout<<0<<endl;
    else
    {
        for(i=c[0];i>0;i--)
            cout<<c[i];
        cout<<endl;
    }
     
    cout<<"余数为：";
    if(a[0]==0)//输出余数
        cout<<0<<endl;
    else
    {
        for(i=a[0];i>0;i--)
            cout<<a[i];
        cout<<endl;
    }
     
    return 0;
}

```
————————————————
版权声明：本文为CSDN博主「老樊Lu码」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/fanyun_01/article/details/79967170





# 排序算法
八大排序算法（C语言实现）


### 文章目录
直接插入排序
希尔排序
选择排序
堆排序
冒泡排序
快速排序
递归实现
Hoare版本
挖坑法
前后指针法
非递归实现
Hoare版本
挖坑法
前后指针法
快速排序的两个优化
三数取中
小区间优化
归并排序
递归实现
非递归实现
外排序
计数排序

本次内容大纲：

注：下列八大排序的代码均以排升序为例。
### 直接插入排序
动图演示：

 插入排序，又叫直接插入排序。实际中，我们玩扑克牌的时候，就用了插入排序的思想。
基本思想：
 在待排序的元素中，假设前n-1个元素已有序，现将第n个元素插入到前面已经排好的序列中，使得前n个元素有序。按照此法对所有元素进行插入，直到整个序列有序。

 但我们并不能确定待排元素中究竟哪一部分是有序的，所以我们一开始只能认为第一个元素是有序的，依次将其后面的元素插入到这个有序序列中来，直到整个序列有序为止。

代码：

//插入排序
``` C++
void InsertSort(int* a, int n)
{
	int i = 0;
	for (i = 0; i < n - 1; i++)
	{
		int end = i;//记录有序序列的最后一个元素的下标
		int tmp = a[end + 1];//待插入的元素
		while (end >= 0)
		{
			if (tmp < a[end])//还需继续比较
			{
				a[end + 1] = a[end];
				end--;
			}
			else//找到应插入的位置
			{
				break;
			}
		}
		a[end + 1] = tmp;
		//代码执行到此位置有两种情况:
		//1.待插入元素找到应插入位置（break跳出循环到此）。
		//2.待插入元素比当前有序序列中的所有元素都小（while循环结束后到此）。
	}
}
```

时间复杂度：O ( N 2 ) O(N^2)O(N 
2
 )  空间复杂度：O ( 1 ) O(1)O(1)

### 希尔排序
动图演示：

 希尔排序是按其设计者希尔的名字命名的，该算法由希尔1959年公布。希尔可以说是一个脑洞非常大的人，他对普通插入排序的时间复杂度进行分析，得出了以下结论：
 1.普通插入排序的时间复杂度最坏情况下为O(N2)，此时待排序列为逆序，或者说接近逆序。
 2.普通插入排序的时间复杂度最好情况下为O(N)，此时待排序列为升序，或者说接近升序。

于是希尔就想：若是能先将待排序列进行一次预排序，使待排序列接近有序（接近我们想要的顺序），然后再对该序列进行一次直接插入排序。因为此时直接插入排序的时间复杂度为O(N)，那么只要控制预排序阶段的时间复杂度不超过O(N2)，那么整体的时间复杂度就比直接插入排序的时间复杂度低了。

希尔排序，又称缩小增量法。其基本思想是：
 1.先选定一个小于N的整数gap作为第一增量，然后将所有距离为gap的元素分在同一组，并对每一组的元素进行直接插入排序。然后再取一个比第一增量小的整数作为第二增量，重复上述操作…
 2.当增量的大小减到1时，就相当于整个序列被分到一组，进行一次直接插入排序，排序完成。

问题：为什么要让gap由大到小呢？
answer：gap越大，数据挪动得越快；gap越小，数据挪动得越慢。前期让gap较大，可以让数据更快得移动到自己对应的位置附近，减少挪动次数。

注：一般情况下，取序列的一半作为增量，然后依次减半，直到增量为1（也可自己设置）。

举个例子分析一下：
 现在我们用希尔排序对该序列进行排序。

 我们用序列长度的一半作为第一次排序时gap的值，此时相隔距离为5的元素被分为一组（共分了5组，每组有2个元素），然后分别对每一组进行直接插入排序。

 gap的值折半，此时相隔距离为2的元素被分为一组（共分了2组，每组有5个元素），然后再分别对每一组进行直接插入排序。

 gap的值再次减半，此时gap减为1，即整个序列被分为一组，进行一次直接插入排序。

 该题中，前两趟就是希尔排序的预排序，最后一趟就是希尔排序的直接插入排序。

代码：
``` C++
//希尔排序
void ShellSort(int* a, int n)
{
	int gap = n;
	while (gap > 1)
	{
		gap = gap / 2;//gap折半
		int i = 0;
		//进行一趟排序
		for (i = 0; i < n - gap; i++)
		{
			int end = i;
			int tmp = a[end + gap];
			while (end >= 0)
			{
				if (tmp < a[end])
				{
					a[end + gap] = a[end];
					end -= gap;
				}
				else
				{
					break;
				}
			}
			a[end + gap] = tmp;
		}
	}
}
```
时间复杂度：O ( N l o g N ) O(NlogN)O(NlogN)  空间复杂度：O ( 1 ) O(1)O(1)

平均时间复杂度：O ( N 1.3 ) O(N^{1.3})O(N 
1.3
 )

### 选择排序
动图演示：

 选择排序，即每次从待排序列中选出一个最小值，然后放在序列的起始位置，直到全部待排数据排完即可。

代码：
``` c++
//选择排序(一次选一个数)
void SelectSort(int* a, int n)
{
	int i = 0;
	for (i = 0; i < n; i++)//i代表参与该趟选择排序的第一个元素的下标
	{
		int start = i;
		int min = start;//记录最小元素的下标
		while (start < n)
		{
			if (a[start] < a[min])
				min = start;//最小值的下标更新
			start++;
		}
		Swap(&a[i], &a[min]);//最小值与参与该趟选择排序的第一个元素交换位置
	}
}
```
时间复杂度：O ( N 2 ) O(N^2)O(N ²
 )  空间复杂度：O ( 1 ) O(1)O(1)

 实际上，我们可以一趟选出两个值，一个最大值一个最小值，然后将其放在序列开头和末尾，这样可以使选择排序的效率快一倍。

代码：
``` C++ 
//选择排序(一次选两个数)
void SelectSort(int* a, int n)
{
	int left = 0;//记录参与该趟选择排序的第一个元素的下标
	int right = n - 1;//记录参与该趟选择排序的最后一个元素的下标
	while (left < right)
	{
		int minIndex = left;//记录最小元素的下标
		int maxIndex = left;//记录最大元素的下标
		int i = 0;
		//找出最大值及最小值的下标
		for (i = left; i <= right; i++)
		{
			if (a[i] < a[minIndex])
				minIndex = i;
			if (a[i]>a[maxIndex])
				maxIndex = i;
		}
		//将最大值和最小值放在序列开头和末尾
		Swap(&a[minIndex], &a[left]);
		if (left == maxIndex)
		{
			maxIndex = minIndex;//防止最大值位于序列开头，被最小值交换
		}
		Swap(&a[maxIndex], &a[right]);
		left++;
		right--;
	}
}
```

时间复杂度：O ( N 2 ) O(N^2)O(N 
2
 )  空间复杂度：O ( 1 ) O(1)O(1)

### 堆排序
 要学习堆排序，首先要学习堆的向下调整算法，因为要用堆排序，你首先得建堆，而建堆需要执行多次堆的向下调整算法。

堆的向下调整算法（使用前提）：
 若想将其调整为小堆，那么根结点的左右子树必须都为小堆。
 若想将其调整为大堆，那么根结点的左右子树必须都为大堆。

向下调整算法的基本思想（以建大堆为例）：
 1.从根结点处开始，选出左右孩子中值较大的孩子。
 2.让大的孩子与其父亲进行比较。
 若大的孩子比父亲还大，则该孩子与其父亲的位置进行交换。并将原来大的孩子的位置当成父亲继续向下进行调整，直到调整到叶子结点为止。
 若大的孩子比父亲小，则不需处理了，调整完成，整个树已经是大堆了。

图片示例：

堆的向下调整算法代码：
``` C++
//堆的向下调整算法
void AdjustDown(int* a, int n, int root)
{
	int parent = root;
	int child = 2 * parent + 1;//假设左孩子较大
	while (child < n)
	{
		if (child + 1 < n&&a[child + 1] > a[child])//右孩子存在，并且比左孩子大
		{
			child++;//左右孩子的较大值
		}
		if (a[child] > a[parent])
		{
			Swap(&a[child], &a[parent]);
			parent = child;
			child = 2 * parent + 1;
		}
		else//已成堆
		{
			break;
		}
	}
}

```
 使用堆的向下调整算法，最坏的情况下（即一直需要交换结点），需要循环的次数为：h - 1次（h为树的高度）。而h = log2(N+1)（N为树的总结点数）。所以堆的向下调整算法的时间复杂度为：O(logN) 。

 上面说到，使用堆的向下调整算法需要满足其根结点的左右子树均为大堆或是小堆才行，那么如何才能将一个任意树调整为堆呢？
 答案很简单，我们只需要从倒数第一个非叶子结点开始，从后往前，按下标，依次作为根去向下调整即可。

建堆代码：
``` C++
	//建堆
	for (int i = (n - 1 - 1) / 2; i >= 0; i--)
	{
		AdjustDown(php->a, php->size, i);
	}
```
那么建堆的时间复杂度又是多少呢？
 当结点数无穷大时，完全二叉树与其层数相同的满二叉树相比较来说，它们相差的结点数可以忽略不计，所以计算时间复杂度的时候我们可以将完全二叉树看作与其层数相同的满二叉树来进行计算。

我们计算建堆过程中总共交换的次数：
T ( n ) = 1 × ( h − 1 ) + 2 × ( h − 2 ) + . . . + 2 h − 3 × 2 + 2 h − 2 × 1 T(n) = 1\times(h-1) + 2\times(h-2) + ... + 2^{h-3}\times2 + 2^{h-2}\times1T(n)=1×(h−1)+2×(h−2)+...+2 
h−3
 ×2+2 
h−2
 ×1
两边同时乘2得：
2 T ( n ) = 2 × ( h − 1 ) + 2 2 × ( h − 2 ) + . . . + 2 h − 2 × 2 + 2 h − 1 × 1 2T(n) = 2\times(h-1) + 2^2\times(h-2) + ... + 2^{h-2}\times2 + 2^{h-1}\times12T(n)=2×(h−1)+2 
2
 ×(h−2)+...+2 
h−2
 ×2+2 
h−1
 ×1
两式相减得：
T ( n ) = 1 − h + 2 1 + 2 2 + . . . + 2 h − 2 + 2 h − 1 T(n)=1-h+2^1+2^2+...+2^{h-2}+2^{h-1}T(n)=1−h+2 
1
 +2 
2
 +...+2 
h−2
 +2 
h−1

运用等比数列求和得：
T ( n ) = 2 h − h − 1 T(n)=2^h-h-1T(n)=2 
h
 −h−1
由二叉树的性质，有N = 2 h − 1 N=2^h-1N=2 
h
 −1和h = log ⁡ 2 ( N + 1 ) h=\log_2(N+1)h=log 
2
​
 (N+1)，于是
T ( n ) = N − log ⁡ 2 ( N + 1 ) T(n)=N-\log_2(N+1)T(n)=N−log 
2
​
 (N+1)
用大O的渐进表示法：
T ( n ) = O ( N ) T(n)=O(N)T(n)=O(N)

总结一下：
 堆的向下调整算法的时间复杂度：T ( n ) = O ( log ⁡ N ) T(n)=O(\log N)T(n)=O(logN)。
 建堆的时间复杂度：T ( n ) = O ( N ) T(n)=O(N)T(n)=O(N)。

那么堆建好后，如何进行堆排序呢？
步骤如下：
 1、将堆顶数据与堆的最后一个数据交换，然后对根位置进行一次堆的向下调整，但是调整时被交换到最后的那个最大的数不参与向下调整。
 2、完成步骤1后，这棵树除最后一个数之外，其余数又成一个大堆，然后又将堆顶数据与堆的最后一个数据交换，这样一来，第二大的数就被放到了倒数第二个位置上，然后该数又不参与堆的向下调整…反复执行下去，直到堆中只有一个数据时便结束。此时该序列就是一个升序。

堆排序代码：
``` C++
//堆排序
void HeapSort(int* a, int n)
{
	//排升序，建大堆
	//从第一个非叶子结点开始向下调整，一直到根
	int i = 0;
	for (i = (n - 1 - 1) / 2; i >= 0; i--)
	{
		AdjustDown(a, n, i);
	}
	int end = n - 1;//记录堆的最后一个数据的下标
	while (end)
	{
		Swap(&a[0], &a[end]);//将堆顶的数据和堆的最后一个数据交换
		AdjustDown(a, end, 0);//对根进行一次向下调整
		end--;//堆的最后一个数据的下标减一
	}
}

```
时间复杂度：O ( N l o g N ) O(NlogN)O(NlogN)  空间复杂度：O ( 1 ) O(1)O(1)

### 冒泡排序
动图演示：

冒泡排序，该排序的命名非常形象，即一个个将气泡冒出。冒泡排序一趟冒出一个最大（或最小）值。

代码：
``` C++
//冒泡排序
void BubbleSort(int* a, int n)
{
	int end = 0;
	for (end = n - 1; end >= 0; end--)
	{
		int exchange = 0;//记录该趟冒泡排序是否进行过交换
		int i = 0;
		for (i = 0; i < end; i++)
		{
			if (a[i]>a[i + 1])
			{
				Swap(&a[i], &a[i + 1]);
				exchange = 1;
			}
		}
		if (exchange == 0)//该趟冒泡排序没有进行过交换，已有序
			break;
	}
}
```
时间复杂度：O ( N 2 ) O(N^2)O(N 
2
 )  空间复杂度：O ( 1 ) O(1)O(1)

### 快速排序
快速排序是公认的排序之王，快速排序是Hoare于1962年提出的一种二叉树结构的交换排序算法，其基本思想为：
 任取待排序元素序列中的某元素作为基准值，按照该基准值将待排序列分为两子序列，左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值，然后左右序列重复该过程，直到所有元素都排列在相应位置上为止。

对于如何按照基准值将待排序列分为两子序列，常见的方式有：
 1、Hoare版本
 2、挖坑法
 3、前后指针法

递归实现
Hoare版本
单趟的动图演示：

Hoare版本的单趟排序的基本步骤如下：
 1、选出一个key，一般是最左边或是最右边的。
 2、定义一个L和一个R，L从左向右走，R从右向左走。（需要注意的是：若选择最左边的数据作为key，则需要R先走；若选择最右边的数据作为key，则需要L先走）。
 3、在走的过程中，若R遇到小于key的数，则停下，L开始走，直到L遇到一个大于key的数时，将L和R的内容交换，R再次开始走，如此进行下去，直到L和R最终相遇，此时将相遇点的内容与key交换即可。（选取最左边的值作为key）

 经过一次单趟排序，最终使得key左边的数据全部都小于key，key右边的数据全部都大于key。

 然后我们在将key的左序列和右序列再次进行这种单趟排序，如此反复操作下去，直到左右序列只有一个数据，或是左右序列不存在时，便停止操作，因为这种序列可以认为是有序的。

代码：
``` C++
//快速排序（Hoare版本）
void QuickSort1(int* a, int begin, int end)
{
	if (begin >= end)//当只有一个数据或是序列不存在时，不需要进行操作
		return;
		
	int left = begin;//L
	int right = end;//R
	int keyi = left;//key的下标
	while (left < right)
	{
		//right先走，找小
		while (left < right&&a[right] >= a[keyi])
		{
			right--;
		}
		//left后走，找大
		while (left < right&&a[left] <= a[keyi])
		{
			left++;
		}
		if (left < right)//交换left和right的值
		{
			Swap(&a[left], &a[right]);
		}
	}
	int meeti = left;//L和R的相遇点
	Swap(&a[keyi], &a[meeti]);//交换key和相遇点的值

	QuickSort1(a, begin, meeti - 1);//key的左序列进行此操作
	QuickSort1(a, meeti + 1, end);//key的右序列进行此操作
}

```

时间复杂度：O ( N l o g N ) O(NlogN)O(NlogN)

### 挖坑法
单趟的动图演示：

挖坑法的单趟排序的基本步骤如下：
 1、选出一个数据（一般是最左边或是最右边的）存放在key变量中，在该数据位置形成一个坑。
 2、还是定义一个L和一个R，L从左向右走，R从右向左走。（若在最左边挖坑，则需要R先走；若在最右边挖坑，则需要L先走）。
 3、在走的过程中，若R遇到小于key的数，则将该数抛入坑位，并在此处形成一个坑位，这时L再向后走，若遇到大于key的数，则将其抛入坑位，又形成一个坑位，如此循环下去，直到最终L和R相遇，这时将key抛入坑位即可。（选取最左边的作为坑位）

 经过一次单趟排序，最终也使得key左边的数据全部都小于key，key右边的数据全部都大于key。

 然后也是将key的左序列和右序列再次进行这种单趟排序，如此反复操作下去，直到左右序列只有一个数据，或是左右序列不存在时，便停止操作。

代码：
``` C++
//快速排序（挖坑法）
void QuickSort2(int* a, int begin, int end)
{
	if (begin >= end)//当只有一个数据或是序列不存在时，不需要进行操作
		return;

	int left = begin;//L
	int right = end;//R
	int key = a[left];//在最左边形成一个坑位
	while (left < right)
	{
		//right向左，找小
		while (left < right&&a[right] >= key)
		{
			right--;
		}
		//填坑
		a[left] = a[right];
		//left向右，找大
		while (left < right&&a[left] <= key)
		{
			left++;
		}
		//填坑
		a[right] = a[left];
	}
	int meeti = left;//L和R的相遇点
	a[meeti] = key;//将key抛入坑位

	QuickSort2(a, begin, meeti - 1);//key的左序列进行此操作
	QuickSort2(a, meeti + 1, end);//key的右序列进行此操作
}
```

时间复杂度：O ( N l o g N ) O(NlogN)O(NlogN)

前后指针法
单趟的动图演示：

前后指针法的单趟排序的基本步骤如下：
 1、选出一个key，一般是最左边或是最右边的。
 2、起始时，prev指针指向序列开头，cur指针指向prev+1。
 3、若cur指向的内容小于key，则prev先向后移动一位，然后交换prev和cur指针指向的内容，然后cur指针++；若cur指向的内容大于key，则cur指针直接++。如此进行下去，直到cur指针越界，此时将key和prev指针指向的内容交换即可。

 经过一次单趟排序，最终也能使得key左边的数据全部都小于key，key右边的数据全部都大于key。

 然后也还是将key的左序列和右序列再次进行这种单趟排序，如此反复操作下去，直到左右序列只有一个数据，或是左右序列不存在时，便停止操作。

代码：
``` C++
//快速排序（前后指针法）
void QuickSort3(int* a, int begin, int end)
{
	if (begin >= end)//当只有一个数据或是序列不存在时，不需要进行操作
		return;

	//三数取中
	int midIndex = GetMidIndex(a, begin, end);
	Swap(&a[begin], &a[midIndex]);

	int prev = begin;
	int cur = begin + 1;
	int keyi = begin;
	while (cur <= end)//当cur未越界时继续
	{
		if (a[cur] < a[keyi] && ++prev != cur)//cur指向的内容小于key
		{
			Swap(&a[prev], &a[cur]);
		}
		cur++;
	}
	int meeti = prev;//cur越界时，prev的位置
	Swap(&a[keyi], &a[meeti]);//交换key和prev指针指向的内容

	QuickSort3(a, begin, meeti - 1);//key的左序列进行此操作
	QuickSort3(a, meeti + 1, end);//key的右序列进行此操作
}
```
时间复杂度：O ( N l o g N ) O(NlogN)O(NlogN)

非递归实现
 当我们需要将一个用递归实现的算法改为非递归时，一般需要借用一个数据结构，那就是栈。将Hoare版本、挖坑法以及前后指针法的快速排序改为非递归版本，其实主体思想一致，只是调用的单趟排序的算法不同而已。
 于是我们可以先将Hoare版本、挖坑法和前后指针法的单趟排序单独封装起来。然后写一个非递归的快速排序，在函数内部调用单趟排序的函数即可。

Hoare版本
Hoare版本的单趟排序代码：
``` C++
//Hoare版本（单趟排序）
int PartSort1(int* a, int left, int right)
{
	int keyi = left;//key的下标
	while (left < right)
	{
		//right走，找小
		while (left < right&&a[right] >= a[keyi])
		{
			right--;
		}
		//left先走，找大
		while (left < right&&a[left] <= a[keyi])
		{
			left++;
		}
		if (left < right)
		{
			Swap(&a[left], &a[right]);//交换left和right的值
		}
	}
	int meeti = left;//L和R的相遇点
	Swap(&a[keyi], &a[meeti]);//交换key和相遇点的值
	return meeti;//返回相遇点，即key的当前位置
}
```
挖坑法
挖坑法的单趟排序代码：
``` C++
//挖坑法（单趟排序）
int PartSort2(int* a, int left, int right)
{
	int key = a[left];//在最左边形成一个坑位
	while (left < right)
	{
		//right向左，找小
		while (left < right&&a[right] >= key)
		{
			right--;
		}
		//填坑
		a[left] = a[right];
		//left向右，找大
		while (left < right&&a[left] <= key)
		{
			left++;
		}
		//填坑
		a[right] = a[left];
	}
	int meeti = left;//L和R的相遇点
	a[meeti] = key;//将key抛入坑位
	return meeti;//返回key的当前位置
}
```
前后指针法
前后指针法的单趟排序代码：
``` C++
//前后指针法（单趟排序）
int PartSort3(int* a, int left, int right)
{
	int prev = left;
	int cur = left + 1;
	int keyi = left;
	while (cur <= right)//当cur未越界时继续
	{
		if (a[cur] < a[keyi] && ++prev != cur)//cur指向的内容小于key
		{
			Swap(&a[prev], &a[cur]);
		}
		cur++;
	}
	int meeti = prev;//cur越界时，prev的位置
	Swap(&a[keyi], &a[meeti]);//交换key和prev指针指向的内容
	return meeti;//返回key的当前位置
}
```
快速排序的非递归算法基本思路：
 1、先将待排序列的第一个元素的下标和最后一个元素的下标入栈。
 2、当栈不为空时，读取栈中的信息（一次读取两个：一个是L，另一个是R），然后调用某一版本的单趟排序，排完后获得了key的下标，然后判断key的左序列和右序列是否还需要排序，若还需要排序，就将相应序列的L和R入栈；若不需排序了（序列只有一个元素或是不存在），就不需要将该序列的信息入栈。
 3、反复执行步骤2，直到栈为空为止。

代码：
``` C++
//快速排序（非递归实现）
void QuickSortNonR(int* a, int begin, int end)
{
	Stack st;//创建栈
	StackInit(&st);//初始化栈
	StackPush(&st, begin);//待排序列的L
	StackPush(&st, end);//待排序列的R
	while (!StackEmpty(&st))
	{
		int right = StackTop(&st);//读取R
		StackPop(&st);//出栈
		int left = StackTop(&st);//读取L
		StackPop(&st);//出栈
		//该处调用的是Hoare版本的单趟排序
		int keyi = PartSort1(a, left, right);
		if (left < keyi - 1)//该序列的左序列还需要排序
		{
			StackPush(&st, left);//左序列的L入栈
			StackPush(&st, keyi - 1);//左序列的R入栈
		}
		if (keyi + 1 < right)// 该序列的右序列还需要排序
		{
			StackPush(&st, keyi + 1);//右序列的L入栈
			StackPush(&st, right);//右序列的R入栈
		}
	}
	StackDestroy(&st);//销毁栈
}
```
时间复杂度：O ( N l o g N ) O(NlogN)O(NlogN)

快速排序的两个优化
三数取中
 快速排序的时间复杂度是O(NlogN)，是我们在理想情况下计算的结果。在理想情况下，我们每次进行完单趟排序后，key的左序列与右序列的长度都相同：

 若每趟排序所选的key都正好是该序列的中间值，即单趟排序结束后key位于序列正中间，那么快速排序的时间复杂度就是O(NlogN)。

 可是谁能保证你每次选取的key都是正中间的那个数呢？当待排序列本就是一个有序的序列时，我们若是依然每次都选取最左边或是最右边的数作为key，那么快速排序的效率将达到最低：

 可以看到，这种情况下，快速排序的时间复杂度退化为O(N2)。其实，对快速排序效率影响最大的就是选取的key，若选取的key越接近中间位置，则则效率越高。

为了避免这种极端情况的发生，于是出现了三数取中：
 三数取中，当中的三数指的是：最左边的数、最右边的数以及中间位置的数。三数取中就是取这三个数当中，值的大小居中的那个数作为该趟排序的key。这就确保了我们所选取的数不会是序列中的最大或是最小值了。

代码：
``` C++
//三数取中
int GetMidIndex(int* a, int left, int right)
{
	int mid = left + (right - left) / 2;
	if (a[mid] > a[left])
	{
		if (a[mid] < a[right])
			return mid;
		else if (a[left]>a[right])
			return left;
		else
			return right;
	}
	else
	{
		if (a[mid] > a[right])
			return mid;
		else if (a[left] > a[right])
			return right;
		else
			return left;
	}
}
```
注意：当大小居中的数不在序列的最左或是最右端时，我们不是就以居中数的位置作为key的位置，而是将key的值与最左端的值进行交换，这样key就还是位于最左端了，所写代码就无需改变，而只需在单趟排序代码开头加上以下两句代码即可：
``` C++
	int midIndex = GetMidIndex(a, begin, end);//获取大小居中的数的下标
	Swap(&a[begin], &a[midIndex]);//将该数与序列最左端的数据交换
	//以下代码保持不变...
```

小区间优化
 我们可以看到，就算是上面理想状态下的快速排序，也不能避免随着递归的深入，每一层的递归次数会以2倍的形式快速增长。
 为了减少递归树的最后几层递归，我们可以设置一个判断语句，当序列的长度小于某个数的时候就不再进行快速排序，转而使用其他种类的排序。小区间优化若是使用得当的话，会在一定程度上加快快速排序的效率，而且待排序列的长度越长，该效果越明显。

代码示例：
``` C++
//优化后的快速排序
void QuickSort0(int* a, int begin, int end)
{
	if (begin >= end)//当只有一个数据或是序列不存在时，不需要进行操作
		return;

	if (end - begin + 1 > 20)//可自行调整
	{
		//可调用快速排序的单趟排序三种中的任意一种
		//int keyi = PartSort1(a, begin, end);
		//int keyi = PartSort2(a, begin, end);
		int keyi = PartSort3(a, begin, end);
		QuickSort(a, begin, keyi - 1);//key的左序列进行此操作
		QuickSort(a, keyi + 1, end);//key的右序列进行此操作
	}
	else
	{
		//HeapSort(a, end - begin + 1);
		ShellSort(a, end - begin + 1);//当序列长度小于等于20时，使用希尔排序
	}
}
```
### 归并排序
动图演示：

 归并排序是采用分治法的一个非常典型的应用。其基本思想是：将已有序的子序合并，从而得到完全有序的序列，即先使每个子序有序，再使子序列段间有序。

 相信大家都知道如何将两个有序序列合为一个有序序列吧：

 那么如何得到有序的子序列呢？当序列分解到只有一个元素或是没有元素时，就可以认为是有序了，这时分解就结束了，开始合并：


递归实现
 归并排序，从其思想上看就很适合使用递归来实现，并且用递归实现也比较简单。其间我们需要申请一个与待排序列大小相同的数组用于合并过程两个有序的子序列，合并完毕后再将数据拷贝回原数组。

代码：
``` C++
//归并排序（子函数）
void _MergeSort(int* a, int left, int right, int* tmp)
{
	if (left >= right)//归并结束条件：当只有一个数据或是序列不存在时，不需要再分解
	{
		return;
	}
	int mid = left + (right - left) / 2;//中间下标
	_MergeSort(a, left, mid, tmp);//对左序列进行归并
	_MergeSort(a, mid + 1, right, tmp);//对右序列进行归并
	int begin1 = left, end1 = mid;
	int begin2 = mid + 1, end2 = right;
	//将两段子区间进行归并，归并结果放在tmp中
	int i = left;
	while (begin1 <= end1&&begin2 <= end2)
	{
		//将较小的数据优先放入tmp
		if (a[begin1] < a[begin2])
			tmp[i++] = a[begin1++];
		else
			tmp[i++] = a[begin2++];
	}
	//当遍历完其中一个区间，将另一个区间剩余的数据直接放到tmp的后面
	while (begin1 <= end1)
		tmp[i++] = a[begin1++];
	while (begin2 <= end2)
		tmp[i++] = a[begin2++];
	//归并完后，拷贝回原数组
	int j = 0;
	for (j = left; j <= right; j++)
		a[j] = tmp[j];
}
//归并排序（主体函数）
void MergeSort(int* a, int n)
{
	int* tmp = (int*)malloc(sizeof(int)*n);//申请一个与原数组大小相同的空间
	if (tmp == NULL)
	{
		printf("malloc fail\n");
		exit(-1);
	}
	_MergeSort(a, 0, n - 1, tmp);//归并排序
	free(tmp);//释放空间
}
```
时间复杂度：O ( N l o g N ) O(NlogN)O(NlogN)  空间复杂度：O ( N ) O(N)O(N)

非递归实现
 归并排序的非递归算法并不需要借助栈来完成，我们只需要控制每次参与合并的元素个数即可，最终便能使序列变为有序：

 当然，以上例子是一个待排序列长度比较特殊的例子，我们若是想写出一个广泛适用的程序，必定需要考虑到某些极端情况：
情况一：
 当最后一个小组进行合并时，第二个小区间存在，但是该区间元素个数不够gap个，这时我们需要在合并序列时，对第二个小区间的边界进行控制。

情况二：
 当最后一个小组进行合并时，第二个小区间不存在，此时便不需要对该小组进行合并。

情况三：
 当最后一个小组进行合并时，第二个小区间不存在，并且第一个小区间的元素个数不够gap个，此时也不需要对该小组进行合并。（可与情况二归为一类）

 只要把控好这三种特殊情况，写出归并排序的非递归算法便轻而易举了。

代码：
``` C++
//归并排序（子函数）
void _MergeSortNonR(int* a, int* tmp, int begin1, int end1, int begin2, int end2)
{
	int j = begin1;
	//将两段子区间进行归并，归并结果放在tmp中
	int i = begin1;
	while (begin1 <= end1&&begin2 <= end2)
	{
		//将较小的数据优先放入tmp
		if (a[begin1] < a[begin2])
			tmp[i++] = a[begin1++];
		else
			tmp[i++] = a[begin2++];
	}
	//当遍历完其中一个区间，将另一个区间剩余的数据直接放到tmp的后面
	while (begin1 <= end1)
		tmp[i++] = a[begin1++];
	while (begin2 <= end2)
		tmp[i++] = a[begin2++];
	//归并完后，拷贝回原数组
	for (; j <= end2; j++)
		a[j] = tmp[j];
}
//归并排序（主体函数）
void MergeSortNonR(int* a, int n)
{
	int* tmp = (int*)malloc(sizeof(int)*n);//申请一个与待排序列大小相同的空间，用于辅助合并序列
	if (tmp == NULL)
	{
		printf("malloc fail\n");
		exit(-1);
	}
	int gap = 1;//需合并的子序列中元素的个数
	while (gap < n)
	{
		int i = 0;
		for (i = 0; i < n; i += 2 * gap)
		{
			int begin1 = i, end1 = i + gap - 1;
			int begin2 = i + gap, end2 = i + 2 * gap - 1;
			if (begin2 >= n)//最后一组的第二个小区间不存在或是第一个小区间不够gap个，此时不需要对该小组进行合并
				break;
			if (end2 >= n)//最后一组的第二个小区间不够gap个，则第二个小区间的后界变为数组的后界
				end2 = n - 1;
			_MergeSortNonR(a, tmp, begin1, end1, begin2, end2);//合并两个有序序列
		}
		gap = 2 * gap;//下一趟需合并的子序列中元素的个数翻倍
	}
	free(tmp);//释放空间
}
```
时间复杂度：O ( N l o g N ) O(NlogN)O(NlogN)  空间复杂度：O ( N ) O(N)O(N)

### 外排序
首先，我先说明一下什么是内排序，什么是外排序：
 内排序：数据量相对少一些，可以放到内存中进行排序。
 外排序：数据量较大，内存中放不下，数据只能放到磁盘文件中，需要排序。

 上面介绍的排序算法均是在内存中进行的，对于数据量庞大的序列，上面介绍的排序算法都束手无策，而归并排序却能胜任这种海量数据的排序。

 假设现在有10亿个整数（4GB）存放在文件A中，需要我们进行排序，而内存一次只能提供512MB空间，归并排序解决该问题的基本思路如下：
 1、每次从文件A中读取八分之一，即512MB到内存中进行排序（内排序），并将排序结果写入到一个文件中，然后再读取八分之一，重复这个过程。那么最终会生成8个各自有序的小文件（A1~A8）。
 2、对生成的8个小文件进行11合并，最终8个文件被合成为4个，然后再11合并，就变成2个文件了，最后再进行一次11合并，就变成1个有序文件了。

注意：这里将两个文件进行11合并，并不是先将两个文件读入内存然后进行合并，因为内存装不下。这里的11合并是利用文件输入输出函数，从两个文件中各自读取一个数据，然后进行比较，将较小的数据写入到一个新文件中去，然后再读取，再比较，再写入，最终将两个文件中的数据全部写入到另一个文件中去，那么此时这个文件又是一个有序的文件了。

当然，你也可以这样合并文件：

外排序代码示例：
``` C++
//将file1文件和file2文件中的数据归并到mfile文件中
void _MergeFile(const char* file1, const char* file2, const char* mfile)
{
	FILE* fout1 = fopen(file1, "r");//打开file1文件
	if (fout1 == NULL)
	{
		printf("打开文件失败\n");
		exit(-1);
	}

	FILE* fout2 = fopen(file2, "r");//打开file2文件
	if (fout2 == NULL)
	{
		printf("打开文件失败\n");
		exit(-1);
	}

	FILE* fin = fopen(mfile, "w");//打开mfile文件
	if (fin == NULL)
	{
		printf("打开文件失败\n");
		exit(-1);
	}

	int num1, num2;
	int ret1 = fscanf(fout1, "%d\n", &num1);//读取file1文件中的数据
	int ret2 = fscanf(fout2, "%d\n", &num2);//读取file2文件中的数据
	while (ret1 != EOF && ret2 != EOF)
	{
		//将读取到的较小值写入到mfile文件中，继续从file1和file2中读取数据进行比较
		if (num1 < num2)
		{
			fprintf(fin, "%d\n", num1);
			ret1 = fscanf(fout1, "%d\n", &num1);
		}
		else
		{
			fprintf(fin, "%d\n", num2);
			ret2 = fscanf(fout2, "%d\n", &num2);
		}
	}
	//将file1文件中未读取完的数据写入文件mfile中
	while (ret1 != EOF)
	{
		fprintf(fin, "%d\n", num1);
		ret1 = fscanf(fout1, "%d\n", &num1);
	}
	//将file2文件中未读取完的数据写入文件mfile中
	while (ret2 != EOF)
	{
		fprintf(fin, "%d\n", num2);
		ret2 = fscanf(fout2, "%d\n", &num2);
	}
	fclose(fout1);//关闭file1文件
	fclose(fout2);//关闭file2文件
	fclose(fin);//关闭mfile文件
}
//将文件中的数据进行排序
void MergeSortFile(const char* file)
{
	FILE* fout = fopen(file, "r");//打开文件
	if (fout == NULL)
	{
		printf("打开文件失败\n");
		exit(-1);
	}
	// 分割成一段一段数据，内存排序后写到小文件中
	int n = 10;//一次读取10个数据进行内排序
	int a[10];//读取数据放到数组中，准备进行内排序
	int i = 0;
	int num = 0;
	char subfile[20];//文件名字符串
	int filei = 1;//储存第filei组内排序后的数据的文件的文件名

	memset(a, 0, sizeof(int)*n);//将数组a的空间置0
	while (fscanf(fout, "%d\n", &num) != EOF)//从文件中读取数据
	{
		if (i < n - 1)//读取前9个数据
		{
			a[i++] = num;
		}
		else//读取第10个数据
		{
			a[i] = num;
			QuickSort(a, 0, n - 1);//将这10个数据进行快速排序
			sprintf(subfile, "%d", filei++);//将储存第filei组内排序后的数据的文件的文件名命名为filei
			FILE* fin = fopen(subfile, "w");//创建一个以字符串subfile[20]为名字的文件并打开
			if (fin == NULL)
			{
				printf("打开文件失败\n");
				exit(-1);
			}
			//将内排序排好的数据写入到subfile文件中
			for (int i = 0; i < n; i++)
			{
				fprintf(fin, "%d\n", a[i]);
			}
			fclose(fin);//关闭subfile文件

			i = 0;
			memset(a, 0, sizeof(int)*n);//将a数组内存置0，准备再次读取10个数据进行内排序
		}
	}
	// 利用互相归并到文件，实现整体有序
	char mfile[100] = "12";//归并后文件的文件名
	char file1[100] = "1";//待归并的第一个文件的文件名
	char file2[100] = "2";//待归并的第二个文件的文件名
	for (int i = 2; i <= n; ++i)
	{
		//将file1文件和file2文件中的数据归并到mfile文件中
		_MergeFile(file1, file2, mfile);

		strcpy(file1, mfile);//下一次待归并的第一个文件就是上一次归并好的文件
		sprintf(file2, "%d", i + 1);//上一次待归并的第二个文件的文件名加一，就是下一次待归并的第二个文件的文件名
		sprintf(mfile, "%s%d", mfile, i + 1);//下一次归并后文件的文件名
	}

	fclose(fout);//关闭文件
}
//主函数
int main()
{
	MergeSortFile("Sort.txt");//将Sort.txt文件中的数据进行排序
	return 0;
}
```
注：代码中使用的是第二种文件合并的方式。

### 计数排序
 计数排序，又叫非比较排序。顾名思义，该算法不是通过比较数据的大小来进行排序的，而是通过统计数组中相同元素出现的次数，然后通过统计的结果将序列回收到原来的序列中。

举个例子：

 上列中的映射方法称为绝对映射，即arr数组中的元素是几就在count数组中下标为几的位置++，但这样会造成空间浪费。例如，我们要将数组：1020,1021,1018，进行排序，难道我们要开辟1022个整型空间吗？
 若是使用计数排序，我们应该使用相对映射，简单来说，数组中的最小值就相对于count数组中的0下标，数组中的最大值就相对于count数组中的最后一个下标。这样，对于数组：1020,1021,1018，我们就只需要开辟用于储存4个整型的空间大小了，此时count数组中下标为i的位置记录的实际上是1018+i这个数出现的次数。

总结：
 绝对映射：count数组中下标为i的位置记录的是arr数组中数字i出现的次数。
 相对映射：count数组中下标为i的位置记录的是arr数组中数字min+i出现的次数。

注：计数排序只适用于数据范围较集中的序列的排序，若待排序列的数据较分散，则会造成空间浪费，并且计数排序只适用于整型排序，不适用与浮点型排序。

代码：
``` C++
//计数排序
void CountSort(int* a, int n)
{
	int min = a[0];//记录数组中的最小值
	int max = a[0];//记录数组中的最大值
	for (int i = 0; i < n; i++)
	{
		if (a[i] < min)
			min = a[i];
		if (a[i] > max)
			max = a[i];
	}
	int range = max - min + 1;//min和max之间的自然数个数（包括min和max本身）
	int* count = (int*)calloc(range, sizeof(int));//开辟可储存range个整型的内存空间，并将内存空间置0
	if (count == NULL)
	{
		printf("malloc fail\n");
		exit(-1);
	}
	//统计相同元素出现次数（相对映射）
	for (int i = 0; i < n; i++)
	{
		count[a[i] - min]++;
	}
	int i = 0;
	//根据统计结果将序列回收到原来的序列中
	for (int j = 0; j < range; j++)
	{
		while (count[j]--)
		{
			a[i++] = j + min;
		}
	}
	free(count);//释放空间
```


时间复杂度：O ( N + r a n g e ) O(N+range)O(N+range)  空间复杂度：O ( r a n g e ) O(range)O(range)


# 搜索与回溯算法
搜索与回溯算法

温柔的谢世杰 2019-06-13 16:38:04  5751  收藏 57
分类专栏： 算法
版权

算法
专栏收录该内容
43 篇文章0 订阅
订阅专栏
为了求得问题的解，先选择某一种可能情况向前探索，在探索过程中，一旦发现原来的选择是错误的，就退回一步重新选择，继续向前探索，如此反复进行，直至得到解或证明无解。

一、前言
搜索与回溯是计算机解题中常用的算法，很多问题无法根据某种确定的计算法则来求解，可以利用搜索与回溯的技术求解。回溯是搜索算法中的一种控制策略。它的基本思想是：为了求得问题的解，先选择某一种可能情况向前探索，在探索过程中，一旦发现原来的选择是错误的，就退回一步重新选择，继续向前探索，如此反复进行，直至得到解或证明无解。

如迷宫问题：进入迷宫后，先随意选择一个前进方向，一步步向前试探前进,如果碰到死胡同，说明前进方向已无路可走，这时，首先看其它方向是否还有路可走，如果有路可走，则沿该方向再向前试探；如果已无路可走，则返回一步，再看其它方向是否还有路可走；如果有路可走，则沿该方向再向前试探。按此原则不断搜索回溯再搜索，直到找到新的出路或从原路返回入口处无解为止。

二、搜索框架
递归回溯法算法框架[一]
``` C++
int Search(int k)
{
　for (i=1;i<=算符种数;i++)
　　if (满足条件)
　　   {
　　　　保存结果
　　　　if (到目的地) 输出解;
　　　           else Search(k+1);
　　　　恢复：保存结果之前的状态{回溯一步}
　 　  }
}
递归回溯法算法框架[二]
int Search(int k)
　{
　  if  (到目的地) 输出解;
　　　else
　　　　for (i=1;i<=算符种数;i++)
　　　　　if  (满足条件) 
　　　　　　　{
　　　　　　　　保存结果;
　　　                  Search(k+1);
　　　　　　　　恢复：保存结果之前的状态{回溯一步}
　　　　　　　}
　}

``` C++

三、例题
【例1】
【题目】素数环:从1到20这20个数摆成一个环，要求相邻的两个数的和是一个素数。
【算法分析】
非常明显，这是一道回溯的题目。从1开始，每个空位有20种可能，只要填进去的数合法：与前面的数不相同；与左边相邻的数的和是一个素数。第20个数还要判断和第1个数的和是否素数。
【算法流程】
1、数据初始化； 2、递归填数：判断第i个数填入是否合法；
A、如果合法：填数；判断是否到达目标（20个已填完）：是，打印结果；不是，递归填下一个；
B、如果不合法：选择下一种可能；
``` C++
#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<cmath>
using namespace std;
bool b[21]={0};
int total=0,a[21]={0};
int search(int);                           //回溯过程
int print();                               //输出方案
bool pd(int,int);                          //判断素数
int main()
{
    search(1);
    cout<<total<<endl;                    //输出总方案数
}
int search(int t)
{
    int i;
    for (i=1;i<=20;i++)                     //有20个数可选
     if (pd(a[t-1],i)&&(!b[i]))            //判断与前一个数是否构成素数及该数是否可用
      {
         a[t]=i;
         b[i]=1;
         if (t==20) { if (pd(a[20],a[1])) print();}
             else search(t+1);
         b[i]=0;
      }
}
int print()
{
   total++;
   cout<<"<"<<total<<">";
   for (int j=1;j<=20;j++)
     cout<<a[j]<<" ";
   cout<<endl; 
  }
//若一个数 n 不能被 2 和√n 之间的数整除（取余为 0），则可判断 n 为素数。
bool pd(int x,int y)
{
    int k=2,i=x+y;
    while (k<=sqrt(i)&&i%k!=0) k++;
    if (k>sqrt(i)) return 1;
       else return 0;
}
//最终答案有6309300种方式
``` C++
【例2】
【题目】设有n个整数的集合｛1,2,…,n｝，从中取出任意r个数进行排列（r<n），试列出所有的排列。
``` C++
/**
搜索和回溯基本框架
search(i)
{
	for(所有算子){
		if(条件成立){
			存储结果
			if(到达目的地) 输出
			else search(i+1)
			回溯
		}
	}
}
*/
#include<cstdio>
#include<iostream>
#include<iomanip>
using namespace std;
int num=0,a[10001]= {0},n,r;
bool b[10001]= {0};
int search(int);       //回溯过程
int print();         //输出方案

int main() {
	cout<<"input n,r:";
	cin>>n>>r;
	search(1);
	cout<<"number="<<num<<endl;     //输出方案总数
}
int search(int k) {
	int i;
	for (i=1; i<=n; i++)
		if  (!b[i]) {    //判断i是否可用
			a[k]=i;   //保存结果
			b[i]=1;
			if (k==r) print();
			else search(k+1);
			b[i]=0;
		}
}
int print() {
	num++;
	for (int i=1; i<=r; i++)
		cout<<setw(3)<<a[i];
	cout<<endl;
}
``` C++
【例3】
【题目】任何一个大于1的自然数n，总可以拆分成若干个小于n的自然数之和。
当n=7共14种拆分方法：
7=1+1+1+1+1+1+1
7=1+1+1+1+1+2
7=1+1+1+1+3
7=1+1+1+2+2
7=1+1+1+4
7=1+1+2+3
7=1+1+5
7=1+2+2+2
7=1+2+4
7=1+3+3
7=1+6
7=2+2+3
7=2+5
7=3+4
total=14
【参考程序】
``` C++
#include<cstdio>
#include<iostream>
#include<cstdlib>
using namespace std;
int a[10001]= {1},n,total;
int search(int,int);//在指定开始位置的数组中存储指定大小的数
int print(int);
int main() {
	cin>>n;
	search(n,1);
	//将要拆分的数n传递给s
	cout<<"total="<<total<<endl;
	//输出拆分的方案数
}
int search(int s,int t) {
	int i;
	for (i=a[t-1]; i<=s; i++)
		if (i<n)
//当前数i要大于等于前1位数，且不过n
		{
			a[t]=i;
//保存当前拆分的数i
			s-=i;
//s减去数i， s的值将继续拆分
			if (s==0) print(t);
//当s=0时，拆分结束输出结果
			else search(s,t+1);
//当s>0时，继续递归
			s+=i;
//回溯：加上拆分的数，以便产分所有可能的拆分
		}
}
int print(int t) {
	cout<<n<<"=";
	for (int i=1; i<=t-1; i++)
//输出一种拆分方案
		cout<<a[i]<<"+";
	cout<<a[t]<<endl;
	total++;
//方案数累加1
}
``` C++
【例4】
【题目】八皇后问题：要在国际象棋棋盘中放八个皇后，使任意两个皇后都不能互相吃。（提示：皇后能吃同一行、同一列、同一对角线的任意棋子。）
放置第ｉ个(行)皇后的算法为：
int search(i)；
　{
　　 int j;
　　　for (第i个皇后的位置j=1;j<=8;j++ ) //在本行的8列中去试
　　　if (本行本列允许放置皇后)
　　　　{
　　　　　放置第i个皇后；
对放置皇后的位置进行标记；
　　　　　if (i==8) 输出 //已经放完个皇后
　　　　　　 else search(i+1)； //放置第i+1个皇后
　　　　　对放置皇后的位置释放标记，尝试下一个位置是否可行；
　　　　}
　}
【算法分析】
显然问题的关键在于如何判定某个皇后所在的行、列、斜线上是否有别的皇后；可以从矩阵的特点上找到规律，如果在同一行，则行号相同；如果在同一列上，则列号相同；如果同在／ 斜线上的行列值之和相同；如果同在＼ 斜线上的行列值之差相同；从下图可验证：

考虑每行有且仅有一个皇后，设一维数组Ａ[1…8]表示皇后的放置：第ｉ行皇后放在第ｊ列，用Ａ[i]＝j来表示，即下标是行数，内容是列数。例如：A[3]=5就表示第3个皇后在第3行第5列上。
判断皇后是否安全，即检查同一列、同一对角线是否已有皇后，建立标志数组ｂ[1…8]控制同一列只能有一个皇后，若两皇后在同一对角线上，则其行列坐标之和或行列坐标之差相等，故亦可建立标志数组ｃ[1…16]、ｄ[-7…7]控制同一对角线上只能有一个皇后。
如果斜线不分方向，则同一斜线上两皇后的行号之差的绝对值与列号之差的绝对值相同。在这种方式下，要表示两个皇后I和J不在同一列或斜线上的条件可以描述为：A[I]<>A[J] AND ABS(I-J)<>ABS(A[I]-A[J]){I和J分别表示两个皇后的行号}
【参考程序】
``` C++
#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<iomanip>
using namespace std;
bool d[100]={0},b[100]={0},c[100]={0};
int sum=0,a[100];
int search(int);
int print();
int main()
{
   search(1);                                                          //从第1个皇后开始放置
}
int search(int i)
{
	int j;
	for (j=1;j<=8;j++)                                              //每个皇后都有8位置(列)可以试放
		if ((!b[j])&&(!c[i+j])&&(!d[i-j+7]))                   //寻找放置皇后的位置
		//由于C++不能操作负数组，因此考虑加7
		{                                                                  //放置皇后,建立相应标志值
			a[i]=j;                                                          //摆放皇后
			b[j]=1;                                                         //宣布占领第j列
			c[i+j]=1;                                                      //占领两个对角线
			d[i-j+7]=1;
			if (i==8) print();                                           //８个皇后都放置好,输出
			else search(i+1);                                      //继续递归放置下一个皇后
			b[j]=0;                                                        //递归返回即为回溯一步,当前皇后退出
			c[i+j]=0;
			d[i-j+7]=0;
		}
}
int print()
{
    int i;
    sum++;                                                        //方案数累加1
    cout<<"sum="<<sum<<endl;
    for (i=1;i<=8;i++)                                         //输出一种方案
		cout<<setw(4)<<a[i];
    cout<<endl; 
}
```
【例5】
马的遍历，中国象棋半张棋盘如图4（a）所示。马自左下角往右上角跳。今规定只许往右跳，不许往左跳。比如图4（a）中所示为一种跳行路线，并将所经路线打印出来。打印格式为：0,0->2,1->3,3->1,4->3,5->2,7->4,8…

【算法分析】
如图4（b）,马最多有四个方向，若原来的横坐标为j、纵坐标为i,则四个方向的移动可表示为：
1: （i,j）→（i+2,j+1）； (i<3,j<8)
2: （i,j）→（i+1,j+2）； (i<4,j<7)
3: （i,j）→（i-1,j+2）； (i>0,j<7)
4: （i,j）→（i-2,j+1）； (i>1,j<8)
搜索策略：
S1:Ａ[１]:=(0,0);
S2:从Ａ[1]出发，按移动规则依次选定某个方向，如果达到的是（4,8）则转向S3,否则继续搜索下一个到达的顶点；
S3:打印路径。
``` C++
#include<cstdio>
#include<iostream>
#include<cstdlib>
using namespace std;
int a[100][100],t=0;                 //路径总数和路径
int x[4]={2,1,-1,-2},                 //四种移动规则
y[4]={1,2,2,1};
int search(int);                       //搜索 
int print(int);                           //打印
int main()                               //主程序
{
	a[1][1]=0;a[1][2]=0;             //从坐标(0,0)开始往右跳第二步
	search(2); 
};         
int search(int i)
{
	for (int j=0;j<=3;j++)                                  //往4个方向跳
	if (a[i-1][1]+x[j]>=0&&a[i-1][1]+x[j]<=4
		&&a[i-1][2]+y[j]>=0&&a[i-1][2]+y[j]<=8) //判断马不越界
	{
		a[i][1]=a[i-1][1]+x[j];                              //保存当前马的位置
		a[i][2]=a[i-1][2]+y[j];
		if(a[i][1]==4&&a[i][2]==8) print(i);
		else search(i+1);    //搜索下一步
	}
}
int print(int ii)
{
	t++;
	cout<<t<<":  ";
	for(int i=1;i<=ii-1;i++)
		cout<<a[i][1]<<","<<a[i][2]<<"-->";
	cout<<"4,8"<<endl;
}
``` C++
————————————————
版权声明：本文为CSDN博主「温柔的谢世杰」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_33945246/article/details/91873145


# 贪心算法
      贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，但对范围相当广泛的许多问题他能产生整体最优解或者是整体最优解的近似解。

基本思路：

⒈ 建立数学模型来描述问题。

⒉ 把求解的问题分成若干个子问题。

⒊ 对每一子问题求解，得到子问题的局部最优解。

⒋ 把子问题的解局部最优解合成原来解问题的一个解。

该算法存在问题：

 1. 不能保证求得的最后解是最佳的；

 2. 不能用来求最大或最小解问题；

 3. 只能求满足某些约束条件的可行解的范围。

实现该算法的过程：

   从问题的某一初始解出发;

    while 能朝给定总目标前进一步 do

    求出可行解的一个解元素;

    由所有解元素组合成问题的一个可行解。

贪心选择性质： 

    所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，换句话说，当考虑做何种选择的时候，我们只考虑对当前问题最佳的选择而不考虑子问题的结果。这是贪心算法可行的第一个基本要素。贪心算法以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题。对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。

最优子结构性质：

当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用贪心算法求解的关键特征。
贪心算法思想：

顾名思义，贪心算法总是作出在当前看来最好的选择。也就是说贪心算法并不从整体最优考虑，它所作出的选择只是在某种意义上的局部最优选择。当然，希望贪心算法得到的最终结果也是整体最优的。虽然贪心算法不能对所有问题都得到整体最优解，但对许多问题它能产生整体最优解。如单源最短路经问题，最小生成树问题等。在一些情况下，即使贪心算法不能得到整体最优解，其最终结果却是最优解的很好近似。

贪心算法的基本要素：

1.贪心选择性质。所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。

动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常以自顶向下的方式进行，以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题。

对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。

2. 当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法或贪心算法求解的关键特征。

贪心算法的基本思路：

从问题的某一个初始解出发逐步逼近给定的目标，以尽可能快的地求得更好的解。当达到算法中的某一步不能再继续前进时，算法停止。

该算法存在问题：

1. 不能保证求得的最后解是最佳的；

2. 不能用来求最大或最小解问题；

3. 只能求满足某些约束条件的可行解的范围。

实现该算法的过程：

从问题的某一初始解出发；

while 能朝给定总目标前进一步 do

　　 求出可行解的一个解元素；

由所有解元素组合成问题的一个可行解；

用背包问题来介绍贪心算法：

背包问题：有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。

物品 A B C D E F G

重量 35 30 60 50 40 10 25

价值 10 40 30 50 35 40 30

分析如下

目标函数： ∑pi最大

约束条件是装入的物品总重量不超过背包容量：∑wi<=M( M=150)。

（1）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？

（2）每次挑选所占重量最小的物品装入是否能得到最优解？

（3）每次选取单位重量价值最大的物品，成为解本题的策略。

值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。

贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。

可惜的是，它需要证明后才能真正运用到题目的算法中。

一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。

对于背包问题中的3种贪心策略，都是无法成立（无法被证明）的，解释如下：

贪心策略：选取价值最大者。反例：

W=30

物品：A B C

重量：28 12 12

价值：30 20 20

根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。

（2）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。

（3）贪心策略：选取单位重量价值最大的物品。反例：

W=30

物品：A B C

重量：28 20 10

价值：28 20 10

根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。但是果在条件中加一句当遇见单位价值相同的时候,优先装重量小的,这样的问题就可以解决.

所以需要说明的是，贪心算法可以与随机化算法一起使用，具体的例子就不再多举了。（因为这一类算法普及性不高，而且技术含量是非常高的，需要通过一些反例确定随机的对象是什么，随机程度如何，但也是不能保证完全正确，只能是极大的几率正确）。

 

网上对于这个装包问题的描述就就只有这些,但是在这里我还是要写一下,假设条件是什么?假设条件是上述几种反例的情况不存在的时候该如何求解:

 
``` c++
#include <iostream>
using namespace std;
 
struct Node
{
	float weight;
	float value;
	bool mark;
	char char_mark;
	float pre_weight_value;
};
 
int main(int argc, char* argv[])
{
	float Weight[7] = {35,30,60,50,40,15,20};
	float Value [7] = {10,40,30,50,35,40,30};
	Node array[7];
	for(int i=0; i<7; i++)
	{
		array[i].value = Value[i];
		array[i].weight = Weight[i];
		array[i].char_mark = 65 + i;
		array[i].mark = false;
		array[i].pre_weight_value = Value[i] / Weight[i];
	}
	
	for(i=0;i<7;i++)
		cout<<array[i].pre_weight_value<<" ";
	cout<<endl;
	
	float weight_all=0.0;
	float value_all = 0.0;
	float max = 0.0;
	char charArray[7];
	int flag,n = 0;
	
	while(weight_all <= 150)
	{
		for(int index=0;index < 7; ++index)
		{
			if(array[index].pre_weight_value > max && array[index].mark == false)
			{
				max = array[index].pre_weight_value ;
				flag = index;
			}
		}
		
		charArray[n++] = array[flag].char_mark;
		array[flag].mark = true;
		weight_all += array[flag].weight;
		value_all += array[flag].value;
		max = 0.0;
	}
	
	for(i=0;i<n-1;i++)
		cout<<charArray[i]<<" ";
	cout<<endl;
	cout<<"weight_all:"<<weight_all- array[n-1].weight<<endl;
	cout<<"value_all:"<<value_all<<endl;
	
	system("pause");
	return 0;
}

```

下面我要说的是，这个算法里面就是采用的贪心第三方案，一般这个方案是成功率最大的，其他两个方案我在这里没有考虑，在这里得到的结果是利用了115容量装了价值195的东西，但是这明显不是最优结果，分明还可以装一个A进去！刚好满足150重量，由于在算法中我单纯的利用第三种贪心方法求解，当剩余的包裹中最优的再加进来的时候已经超过了，所以这个时候可以选择剩余包裹中次优的（如这里选择A），再不行就次次优的，尽量把包裹装满，这样得到的结果就很接近了（不保证一定为最优），但是我们一般不这样来求解，下一文章会介绍动态规划算法来解决这个问题，动态规划很好的弥补了贪心算法的不足！详见下一章！！

 

还需要说明的是，如果包裹是可以拆分的，那这个问题就得到了整体最优解，前面不变，就是当最后一次装进去已经超过容量的时候可以选择只装她的一部分！很多编程题一般是这种情况！


————————————————
版权声明：本文为CSDN博主「lloil」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/effective_coder/article/details/8736718

# 分治算法

分治算法
一、基本概念

在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……

任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。例如，对于n个元素的排序问题，当n=1时，不需任何计算。n=2时，只要作一次比较即可排好序。n=3时只要作3次比较即可，…。而当n较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。
1
二、基本思想及策略

分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。

分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。

如果原问题可分割成k个子问题，1<k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。

三、分治法适用的情况

分治法所能解决的问题一般具有以下几个特征：

1) 该问题的规模缩小到一定的程度就可以容易地解决

2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。

3) 利用该问题分解出的子问题的解可以合并为该问题的解；

4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。

第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；

第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；、

第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。

第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。

四、分治法的基本步骤

分治法在每一层递归上都有三个步骤：

step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；

step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题

step3 合并：将各个子问题的解合并为原问题的解。

它的一般的算法设计模式如下：
``` pascal
Divide-and-Conquer(P)

1. if |P|≤n0

2. then return(ADHOC(P))

3. 将P分解为较小的子问题 P1 ,P2 ,...,Pk

4. for i←1 to k

5. do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi

6. T ← MERGE(y1,y2,...,yk) △ 合并子问题

7. return(T)
```
其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,...,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,...,Pk的相应的解y1,y2,...,yk合并为P的解。

五、分治法的复杂性分析

一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有：
1
T（n）= k T(n/m)+f(n)

通过迭代法求得方程的解：

递归方程及其解只给出n等于m的方幂时T(n)的值，但是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的值可以估计T(n)的增长速度。通常假定T(n)是单调上升的，从而当                  mi≤n<mi+1时，T(mi)≤T(n)<T(mi+1)。 

六、可使用分治法求解的一些经典问题

（1）二分搜索
（2）大整数乘法
（3）Strassen矩阵乘法
（4）棋盘覆盖
（5）合并排序
（6）快速排序
（7）线性时间选择

（8）最接近点对问题
（9）循环赛日程表
（10）汉诺塔
七、依据分治法设计程序时的思维过程

实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。
1
1、一定是先找到最小问题规模时的求解方法
2、然后考虑随着问题规模增大时的求解方法
3、找到求解的递归函数式后（各种规模或因子），设计递归程序即可。


分治法思路：
将整个问题分解成若干小问题后再分而治之。如果分解得到的子问题相对来说还是太大，则可反复使用分治策略将这些子问题分成更小的同类型子问题，直至产生方便求解的子问题，必要时逐步合并这些子问题的解，从而得到问题的解。
分治算法可以由递归过程来表示，因为分治法就是一种找大规模问题与小规模问题关系的方法，是递归设计的一种具体策略。

步骤
1.分解
将原问题分解为若干规模较小，相互独立，与原问题相同的子问题。
2.解决
若干子问题较小而容易被解决则直接解决，否则再继续分解为更小的子问题，直到容易解决。
3.合并
将已求解的各个子问题的解，逐步合并为原问题的解。

有的问题分解后不需要合并子问题的解，此时就不需要再做第3步了。多数问题需要子问题的解，按照题意使用恰当的方法合并成为整个问题的解。需要具体问题具体分析。

算法框架
分治法的一般算法设计模式如下：
``` C
Divide-and-Conquer(int n){
	if(n<=n0){//n为问题规模 ,n0为可解子问题的规模
		解子问题;
		return(子问题的解);
	}
	for(i=1;i<=k;i++){//分解成较小的子问题p1,p2,...,pk
		yi=Divide-and-Conquer(|Pi|);//递归解决
	}
	T=MERGE(y1,y2,...yk);//合并子问题
	return(T);//返回问题的解
}
```
典型二分法
（一）
在算法设计中，每次一个问题分解成的子问题个数一般是固定的，每个子问题的规模也是平均分配的。当每次都将问题分解为原问题规模的一半时，称为二分法。
二分法是分治法较常用的分解策略，数据结构课程中的折半查找、归并排序等算法都是采用此策略实现的。

问题：金块问题

老板有一袋金块（共n块），最优秀的雇员得到其中最重的一块，最差的雇员得到其中最轻的一块，假设有一台比较重量的仪器，我们希望用最少的比较次数找出最重的金块。

方法1：逐个查找比较
最简单的方就是逐个的比较查找，算法类似于选择排序。先拿两块进行比较，留下最重的与下一块比较，直到全部比较完毕就找到了最重的金子

完整代码如下：
``` c
//金块算法1：逐个查找比较
#include<stdio.h>
int main(){
	void maxmin(float a[],int n);//定义查找比较的函数
	float a[5]={5,3,1,9,0};
	int i;
	maxmin(a,5);
	return 0;
} 
void maxmin(float a[],int n){
	float max,min;
	int i;
	int count=0;
	max=min=a[0];
	for(i=1;i<n;i++){
		if(max<a[i]) {//记录每次比较重量最大的金块
			max=a[i];
			count++;
		}
		if(min>a[i]){//记录每次比较重量最小的金块
			min=a[i];
			count++;
		} 
	}
	printf("max=%.2f\nmin=%.2f\ncount=%d\n",max,min,count);//输出结果
}
```
方法2：分治法（二分法）
1.将数据等分为两组（两组数据可能差1），目的是分别选取其中最大值（最小值）。
2.递归分解直到每组元素的个数不大于2，可简单的找到最大值（最小值）。
3.回溯时将分解的两组解大者取大，小者取小

用分治法可以用较少的比较次数解决问题。

完整代码如下：
``` c
//金块算法2:运用递归实现分半查询 
#include<stdio.h>
float a[5]={3,6,9,2,5};
int main(){
	void maxmin(int i,int j,float &fmax,float &fmin,int &count);//fmax的地址,fmin的地址 
	float fmax=0,fmin=0;
	int count=0;
	maxmin(0,4,fmax,fmin,count);
	//传递地址是为了能够把值带出来 
	printf("fmax=%f\nfmin=%f\ncount=%d\n",fmax,fmin,count); 
	return 0;
}
void maxmin(int i,int j,float &fmax,float &fmin,int &count){
	int mid;
	int k;
	float lmax,lmin,rmax,rmin;
	count++;
	//递归结束条件(子问题的解)
	//当分到只剩一个数
	if(i==j){
		fmax=a[i];fmin=a[i];
	} 
	else if(i==j-1){//(i,j为下标，在分解过程中,i总在左,j总在右 )假如只剩两个数 
		if(a[i]>a[j]){
			fmax=a[i];
			fmin=a[j];
		} 
		else if(a[j]>a[i]){
			fmax=a[j];
			fmin=a[i];
		}
	}
	else{//其他情况（还剩很多数），则继续递归分解 
		mid=(i+j)/2;//继续分半
		maxmin(i,mid,lmax,lmin);
		maxmin(mid+1,j,rmax,rmin);
		if(lmax>rmax) fmax=lmax;
		else fmax=rmax;
		if(lmin<rmin) fmin=rmin;
		else fmin=rmin;
	}
}
```
（二）二分法不相似情况
需要构造与原问题相似子问题。

问题：残缺棋盘
残缺棋盘是一个有2k*2k（k>0）个方格的棋盘，其中恰有一个方格残缺，其中残缺的方格用蓝色阴影表示。

①号

②号

③号

④号

这样的棋盘我们成为“三格板”，残缺棋盘问题就是要用这四种三格板覆盖更大的残缺棋盘。在此覆盖中要求：
（1）两个三格板不能重叠。
（2）三格板不能覆盖残缺方格，但必须要覆盖其他所有的方格。

解决：
以k=2为例（此时共有16个小方格），用二分法进行分解，得到的是由4个k=1的棋盘组成。


注意这四个棋盘，并不都是与原问题相似的子问题，只有残缺方格在左上角的棋盘时，左上角1号子棋盘与原问题相似。
既然不是与原问题相似的子问题，自然不能够独立求解，所以我们要用巧妙的方法，将2,3，4号子棋盘也转化成与原问题相似的子问题。

我们把紫色阴影覆盖的方格，也看作是残缺方格（我们称之为“伪”残缺方格），这样，每一个子残缺棋盘就都转化为与原问题相似的子问题了。
这样处理过后：
1号子棋盘可以用③号三格板覆盖
2号子棋盘可以用③号三格板覆盖
3号子棋盘可以用②号三格板覆盖
4号子棋盘可以用①号三格板覆盖

这样就覆盖了所有棋盘，满足题意。
如下图所示，粉色阴影是用题中给出的三格板覆盖的位置。

解决了k=2的情况，相当于解决了所有的情况，因为分治算法就是把大规模问题逐步分解成独立且相似的子问题。
思路清晰了之后，我们来解决一般情况
代码分析：
1.数据结构设计 ：我们用一个二维数组Board[][]来模拟棋盘，覆盖残缺棋盘所需要的三格板数目为（size2-1）/3
（size为棋盘的行数或列数）
2.棋盘识别
我们用左上角方格所在行和列来唯一确定一个棋盘，残缺方格或“伪”残缺方格用行号和列号记录。
tr：棋盘左上角方格所在行
td：棋盘左上角方格所在列
dr：残缺方块所在行
dl：残缺方块所在列
3.棋盘填充
将三格板编号1-（size2-1）/3，将每个方格板的编号填充在代表棋盘的数组中，以这种方式表示棋盘被方格板覆盖。
完整代码如下：
``` c++
#include<iostream>
using namespace std;
int count=0;
int size=1;
int Board[8][8];
int main(){
	void Cover(int tr,int tc,int dr,int dc,int size);//填充棋盘的函数 
	void OutputBoard(int size);
	int x,y;
	int i;
	int k;
	//输入棋盘规模
	cout<<"请确认棋盘规模，输入k大小（2k×2k）:"<<endl ;
	cin>>k;
	for(i=1;i<=k;i++) size=size*2;
	cout<<"请输入残缺棋子位置（行号，列号）:"<<endl;
	cin>>x>>y;
	Cover(0,0,x,y,size);
	OutputBoard(size); 	
} 
	void Cover(int tr,int tc,int dr,int dc,int size){
		if(size<2) return;
		int t=count++;
		int s=size/2;
		//如果残缺在左上角
		if(dr<tr+s&&dc<tc+s){
			Cover(tr,tc,dr,dc,s);
			Board[tr+s-1][tc+s]=t;
			Board[tr+s][tc+s-1]=t;
			Board[tr+s][tc+s]=t;
			//返回，填充其他部分 
			Cover(tr,tc+s,tr+s-1,tc+s,s);
			Cover(tr+s,tc,tr+s,tc+s-1,s);
			Cover(tr+s,tc+s,tr+s,tc+s,s);
		}
		//右上角 
		else if(dr<tr+s&&dc>=tc+s) {
			Cover(tr,tc+s,dr,dc,s);
			Board[tr+s-1][tc+s-1]=t;
			Board[tr+s][tc+s-1]=t;
			Board[tr+s][tc+s]=t;
			//返回，填充其他部分 
			Cover(tr,tc,tr+s-1,tc+s-1,s);
			Cover(tr+s,tc,tr+s,tc+s-1,s);
			Cover(tr+s,tc+s,tr+s,tc+s,s);
		}
		else if(dr>=tr+s&&dc<tc+s){
			Cover(tr+s,tc,dr,dc,s);
			Board[tr+s-1][tc+s-1]=t;
			Board[tr+s-1][tc+s]=t;
			Board[tr+s][tc+s]=t;
			//返回，填充其他部分 
			Cover(tr,tc,tr+s-1,tc+s-1,s);
			Cover(tr,tc+s,tr+s-1,tc+s,s);
			Cover(tr+s,tc+s,tr+s,tc+s,s);
		}
		else if(dr>=tr+s&&dc>=tc+s){
			Cover(tr+s,tc+s,dr,dc,s);
			Board[tr+s-1][tc+s-1]=t;
			Board[tr+s-1][tc+s]=t;
			Board[tr+s][tc+s-1]=t;
			//返回，填充其他部分 
			Cover(tr,tc,tr+s-1,tc+s-1,s);
			Cover(tr,tc+s,tr+s-1,tc+s,s);
			Cover(tr+s,tc,tr+s,tc+s-1,s);
		}
		
}
void OutputBoard(int size){//输出棋盘的内容
			for(int i=0;i<size;i++){
				for(int j=0;j<size;j++){
					cout<<Board[i][j];
					
				}
				cout<<endl;
			}
		}
```

（三）二分法不独立情况
上面的例题，经过二分法分解或经过简单处理后，就得到了相似且相互独立的子问题。对于分解后不独立的情况，主要表现在子问题之间包含公共子问题。
问题：求数列的最大字段和
给定n个元素的整数列（可能为负整数）(斜体标注的都为下标)
a1,a2,…,an.
求形如:ai,ai+1,…aj(i/j=1…n,i<=j)的子段
使其和为最大。当所有整数为负整数时定义其最大字段和为0。
例如当（a1,a2,a3,a4,a5,a6）=(-2,11,-1,13,-5,-2)
最大字段和为i=2,j=4(下标从1开始).
解决：
用二分法将数据分为两组，找出两个子问题的解，两个子问题的解不能简单地得到原问题的解，因为两个子问题的中间还有公共子问题，也就是说两个子问题不能真正的分开。此时再想使用二分法，则需要对公共子问题单独处理。
代码思路：
使用二分法将原问题分解，虽然分解得到的子问题并不相互独立，但是对公共子问题进行单独的处理。
将原问题分解成三部分
（从中间分开）
左边部分
右边部分

中间部分（中间部分单独处理时进行再分）
对左边部分和右边部分：
递归二分，直到分解到只剩一个元素。
对中间部分：
中间部分包含的序列可能是整个序列，把整个序列分为左右两部分，两边各向两侧扩展，最后两边的值相加为中间部分最大字段和。
从中间数据开始向一侧扩展，如果加上元素大于原来的和，则加上此元素，否则跳过这个元素继续扩展。
完整代码如下:
``` C
#include<stdio.h>
int len=5;
int main(){
	double max_sum(double a[],int left,int right);//left,right是数组下标范围 这是一个递归函数
	double max=0;
	double a[5]={-1,-2,0,3,6};
	max=max_sum(a,1,5);
	printf("%.2f\n",max); 
	return 0;         
}
double max_sum(double a[],int left,int right){
	int i;
	double s1=0,s2=0;//中间部分左边为s1,中间部分右边为s2 
	double lefts=0,rights=0;//临时变量标示左边部分的和，和右边部分的和 
	double left_sum=0;
	double right_sum=0;
	double center_sum=0;
	if(left==right){//如果这个数为正数就返回，如果为负数就返回0 
		if(a[left]>0) return (a[left]);
		else return (0);
	}
	else{
		//递归求左边部分和右边部分最大和
		int center=(left+right)/2; 
		left_sum=max_sum(a,left,center);
		right_sum=max_sum(a,center+1,right);
		//对公共子问题进行单独求解
		//求中间部分最大和
		for(i=0;i<center;i++){
			lefts=lefts+a[center-i];
			if(lefts>s1) s1=lefts;
			rights=rights+a[center+i+1];
			if(rights>s2) s2=rights;
		}
		center_sum=s1+s2;
		//比较三部分大小
		if(left_sum>right_sum){
			if(left_sum>center_sum) return (left_sum);
			else return (center_sum);
		} 
		else{
			if(right_sum>center_sum) return (right_sum);
			else return (center_sum);	
		}
	}
}         
```
非等分分治
问题：选择第k小的数
对于给定的n个元素的数组a[0,n-1],要求从中找出第k小的数。
解决：
通过改写快速排序算法来解决选择问题。
（快速排序算法回忆：首先选择第一个数作为分界数据，将比它小的数据存储在它的左边，将比它大的数据存储在它的右边，它存储在左右两个子集中间。这样左右两个子集就是原问题分解后的独立子问题，再用同样的方法解决这些子问题，直到每个数据只有一个数据，就自然有序了，也就完成了全部数据的排序工作。）
代码思路：
一趟排序中分解出的左子集中元素个数nleft，有以下几种情况：
1. nleft=k-1，则分界数据就是选择问题的答案。
2. nleft>k-1,则选择问题的答案在左子集中找，问题规模变小了。
3. 则选择问题的答案在右子集中找，问题变为寻找第k-nleft-1小的数了，问题规模变小了。（因为随着子区间下标不同，k这个答案下标也会变化）

如果直接用快速排序算法的话，需要把数组全部排序后，再找第k小的数。而分治算法是边排边找，节省时间效率。
下面，将通过快速排序的算法和分治算法的比较，来观察两种方法的不同。
完整代码如下：
``` C
#include<stdio.h>
#include<time.h>
#include<math.h>
void swap(int a[],int x,int y);//交换函数
int main(){
	//比较两种算法的时间复杂度
	//快速排序算法函数
	int a[7]={-1,3,-2,7,6,0,9};
	int len=7;//数组长度  
	int k;
	int n=20,i=0;
	double time;
	int num;
	clock_t start,end;
	void kuaisupaixu(int a[],int left,int right); 
	//非等分分治算法
	int feidengfenfenzhi(int a[],int len,int k);
	//输入k 
	printf("查找数组中第k小的数，请输入k（0~7）:");
	scanf("%d",&k);
	/*------------------------------*/
	//调用快速排序算法 
	start=clock();
	for(;i<n;i++){
		kuaisupaixu(a,0,len-1);//一次运行时间太短，运行100次取平均值 
	}
	end=clock();
	time=(double)(end-start)/CLOCKS_PER_SEC/n;
	printf("您要查找的第k小的元素为:%d\n",a[k-1]);
	printf("函数调用时间为：%.30lf\n",time);
	/*------------------------------*/
	//调用非等分分治 
	start=clock();
	for(;i<n;i++){
		num=feidengfenfenzhi(a,len,k);
	}
	end=clock();
	time=(double)(end-start)/CLOCKS_PER_SEC/n;
	printf("您要查找的第k小的元素为:%d\n",num);
	printf("函数调用时间为：%.30lf\n",time);
	/*------------------------------*/
	return 0; 
}
void kuaisupaixu(int a[],int left,int right){
	int temp=a[left];//把第一个变量设置为分界变量 
	int i=left;//左指针赋初值 
	int j=right;//右指针赋初值 
	if(left==right){
		return;
	}
	if(left==right-1){
		if(a[left]>a[right]) swap(a,left,right);
		return;
	}
	//把比分界变量小的数放前面，把比分界变量大的数放在后面 (利用递归把数从小到大排列)
	//实现一次排序 
	while(1&&j>=left&&i<=right){
		//右边扫描 (找出小于分界变量的数 )
		while(a[j]>=temp&&j>=left){
				if(j>i) j=j-1;
				else break;
		}
		//左边扫描(找出大于分界变量的数 )
		while(a[i]<=temp&&i<=right){
			if(i==j) break;
			else i=i+1;
		}
		if(i==j){//每轮探测以i==j结束 
			swap(a,i,left);
			break;
		}
		if(i>=j){
			break; 
		}
		swap(a,i,j);
	}
	//左边递归
	if(i!=left){
		digui(left,i-1);
	} 
	//右边递归
	if(i!=right){
		digui(i+1,right); 
	}
		
}

int feidengfenfenzhi(int a[],int len,int k){
	int digui(int a[],int left,int right,int k); 
	int i;
	if(k<0||k>=len){
		printf("您查找的数字不在数组中！\n");
	}
	else{
		return digui(a,0,len-1,k);
	}
} 
int digui(int a[],int left,int right,int k){
	//利用快速排序思路，找到一个基准数（选第一个），小于基准数的放左边，大于基准数的放右边 
	int i,j;
	int p;
	int temp;
	if(left>=right) return a[left];
	i=left,j=right+1;//指定左右指针（因为用do  while循环所以j先加一） 
	temp=a[left];//指定基准数
	//把小数放前面，大数放后面（从小到大排列） 
	//右边循环
	//指针指向小于基准数的下标，等待交换 
	while(1){	
		do{
			i=i+1;	
		}while(a[i]<temp);//指针向后移动，直到碰到大于temp的数 
		do{
			j=j-1;
		}while(a[j]>temp); //指针向前移动，直到碰到小于temp的数 
		//左边循环 
		//指针指向大于基准数的下标，等待交换 
		if(i>=j) break;
		swap(a,i,j);
	}

	//从循环里出来的时候i==j,且以此时指针指向的数为分界点，划分新的区间进行递归 
	if(j-left+1==k) {

		return temp;
	}
	a[left]=a[j];
	a[j]=temp;
	if(j-left+1<k){//查找的数在右边 
		return digui(a,j+1,right,k-j-1+left);//k的值改变 
	}
	else{//查找的数在左边
		return digui(a,left,j-1,k);
	}
}

void swap(int a[],int x,int y){//传入的x,y为下标 
	int t;//借助额外变量实现两个数的交换 
	t=a[x];
	a[x]=a[y];
	a[y]=t;
}
```


————————————————
版权声明：本文为CSDN博主「nan_black」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_44398094/article/details/109920912


# 动态规划

个人觉得是因为这个名字非常让人困惑。英文dynamic programming，中文动态规划，给人一种很宏大的感觉。但其实对所谓动态和规划都没有那么深的体现，可以简单得理解为是对传统递归的一种优化。Bellman，也就是”发明"了DP的人，自己说这个名字是他“编的”，主要为了规避军方的厌恶，否则就要用什么decision research这种名字了。
(wiki: Dynamic programming)Bellman是个数学家，这里programming不是编程的意思，而是决策。但这种决策不是一下就出来的，而是一步步(multistage)积累出来。换句话说我们需要一个决策，但这个决策太大了，我们做不了，所以需要把他递归到我们可以简单做出决策的状态，然后从这些状态开始，慢慢的“动态地”演进到最终的决策。比如说用最少的硬币换零钱，突然和你说要换78分钱，你怎么就能迅速给出答案呢，你不能。但是如果是1分的话，你就可以，2分的话呢，就是在1分的基础上再加1分，你也可以。于是你就慢慢地从1分开始一直算到78就有答案了。从另一个角度说，如果你用DP算出了怎么换78分，那如果我问你76分怎么换，你也应该有答案了。所以在DP的实践中很重要的就是递推关系和边界条件。所谓边界条件就是最简单的情况，所谓递推关系就是如果你已经知道这么多，再多给你一个，你怎么得到。说一个最最最简单的例子，找出一个数组中的最大值。这个问题边界条件是什么呢，就是如果只有一个元素，那最大值就是他；递推关系是什么，就是你已经知道当下最大的数，再多给你一个数你怎么办。你会拿这个数和当下最大的数去比，其中较大的那个就是新的最大的数。这就是典型dp的思想。
所以不要把DP看的过于高深就好了。-------Bellman对DP名字的起源，自己在他的自传“Eye of the Hurricane: An Autobiography"中写了这样一段话，有兴趣的可以看一下：
（原版第159页）An interesting question is, ‘Where did the name, dynamic programming, come from?’ The 1950s were not good years for mathematical research. We had a very interesting gentleman in Washington named Wilson. He was Secretary of Defense, and he actually had a pathological fear and hatred of the word, research. I’m not using the term lightly; I’m using it precisely. His face would suffuse, he would turn red, and he would get violent if people used the term, research, in his presence. You can imagine how he felt, then, about the term, mathematical. The RAND Corporation was employed by the Air Force, and the Air Force had Wilson as its boss, essentially. Hence, I felt I had to do something to shield Wilson and the Air Force from the fact that I was really doing mathematics inside the RAND Corporation. What title, what name, could I choose? In the first place I was interested in planning, in decision making, in thinking. But planning, is not a good word for various reasons. I decided therefore to use the word, ‘programming.’ I wanted to get across the idea that this was dynamic, this was multistage, this was time-varying—I thought, let’s kill two birds with one stone. Let’s take a word that has an absolutely precise meaning, namely dynamic, in the classical physical sense. It also has a very interesting property as an adjective, and that is it’s impossible to use the word, dynamic, in a pejorative sense. Try thinking of some combination that will possibly give it a pejorative meaning. It’s impossible. Thus, I thought dynamic programming was a good name. It was something not even a Congressman could object to. So I used it as an umbrella for my activities.




``` C++
#include<vector>
#include<iostream>

using namespace std;

class SerchTree{
private:
	TreeNode* root;
public:
	SerchTree();

	//插入节点
	void Insert_Node(TreeNode* root,int val){
		if(NULL == root)
			root = new TreeNode(val);
		else{
			if(val<root->val)
				Insert_Node(root->left,val);
			else{	//一样大就往左走吧
				Insert_Node(root->right,val);
			}
		}
	}

	//从数组中构造二叉搜索树	
	void Create_SerchTree(vector<int>& vec){
		int sz = vec.size();
		for(int i = 0;i<sz;i++){
			Insert_Node(root,vec[i]);
		}
	}

	//搜索某个节点是否存在
	bool SerchNode(TreeNode* root,int val){
		if(NULL == root)
			return false;
		if(val<root->val)
			return SerchNode(root->left,val);
		else if(val>root->val)
			return SerchNode(root->right)
		else
			return ture;
	}
	
	//删除节点
	void DelNode(TreeNode* node){
		TreeNode* temp;
		if(NULL == node->right){	//如果右子节点为空
			temp = node;
			node = node->left;
			delete temp;
		}
		else{	//如果右子节点不空
			temp = node;
			while(NULL != temp->left){
				temp = temp->left;
			}
			node->val = temp->val;
			delete temp;
		}
	}	
	//删除某个节点
	void DelSerchNode(TreeNode* root,int val){
		if(NULL == root)
			return;
		if(val<root->val)
			return DelSerchNode(root->left,val);
		else if(val>root->val)
			return DelSerchNode(root->right)
		else
			DelNode(root);
	}

	//计算二叉树的最大深度
	int maxDepth(Node x) { 	//1.如果根结点为空，则最大深度为0； 
		if (x == null) 
			return 0; 
		
		int max = 0; 
		int maxL = 0; 
		int maxR = 0; 
	
		//2.计算左子树的最大深度； 
		if (x.left != null)  
			maxL = maxDepth(x.left); 
			
		//3.计算右子树的最大深度； 
		if (x.right != null)
			maxR = maxDepth(x.right);
			 
		//4.当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1 
		max = maxL > maxR ? maxL + 1 : maxR + 1; return max; 
	}
```
————————————————
版权声明：本文为CSDN博主「看，未来」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_43762191/article/details/107280503